{"version":3,"sources":["webpack:///../src/index.js","webpack:///../demo/Demo.jsx","webpack:///../demo/App.jsx","webpack:///../demo/App.mdx"],"names":["geolocated","positionOptions","enableHighAccuracy","maximumAge","timeout","Infinity","isOptimisticGeolocationEnabled","userDecisionTimeout","suppressLocationOnMount","watchPosition","geolocationProvider","navigator","WrappedComponent","result","isCurrentlyMounted","clearTimeout","positionError","coords","isGeolocationEnabled","position","funcPosition","setTimeout","isGeolocationAvailable","Boolean","componentDidMount","this","getLocation","componentWillUnmount","cancelUserDecisionTimeout","render","getDisplayName","geoPropTypes","latitude","PropTypes","longitude","altitude","accuracy","altitudeAccuracy","heading","speed","number","code","message","string","bool","formatDegrees","degrees","isLongitude","getDirection","props","style","fontSize","fontWeight","margin","className","JSON","stringify","App","innerRef","useRef","textAlign","onError","error","console","log","ref","onClick","current","type","_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","isMDXComponent"],"mappings":"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","file":"component---demo-app-mdx-ae9d5917e77307b73ff1.js","sourcesContent":["import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\n\nconst getDisplayName = WrappedComponent =>\n    `Geolocated(${WrappedComponent.displayName ||\n        WrappedComponent.name ||\n        \"Component\"})`;\n\nexport const geolocated = ({\n    positionOptions = {\n        enableHighAccuracy: true,\n        maximumAge: 0,\n        timeout: Infinity,\n    },\n    isOptimisticGeolocationEnabled = true,\n    userDecisionTimeout = null,\n    suppressLocationOnMount = false,\n    watchPosition = false,\n    geolocationProvider = typeof navigator !== \"undefined\" &&\n        navigator.geolocation,\n} = {}) => WrappedComponent => {\n    let result = class Geolocated extends Component {\n        isCurrentlyMounted = false;\n\n        constructor(props) {\n            super(props);\n            this.state = {\n                coords: null,\n                isGeolocationAvailable: Boolean(geolocationProvider),\n                isGeolocationEnabled: isOptimisticGeolocationEnabled,\n                positionError: null,\n            };\n        }\n\n        cancelUserDecisionTimeout = () => {\n            if (this.userDecisionTimeoutId) {\n                clearTimeout(this.userDecisionTimeoutId);\n            }\n        };\n\n        onPositionError = positionError => {\n            this.cancelUserDecisionTimeout();\n            if (this.isCurrentlyMounted) {\n                this.setState({\n                    coords: null,\n                    isGeolocationEnabled: false,\n                    positionError,\n                });\n            }\n            if (this.props.onError) {\n                this.props.onError(positionError);\n            }\n        };\n\n        onPositionSuccess = position => {\n            this.cancelUserDecisionTimeout();\n            if (this.isCurrentlyMounted) {\n                this.setState({\n                    coords: position.coords,\n                    isGeolocationEnabled: true,\n                    positionError: null,\n                });\n            }\n            if (this.props.onSuccess) {\n                this.props.onSuccess(position);\n            }\n        };\n\n        getLocation = () => {\n            if (\n                !geolocationProvider ||\n                !geolocationProvider.getCurrentPosition ||\n                !geolocationProvider.watchPosition\n            ) {\n                throw new Error(\"The provided geolocation provider is invalid\");\n            }\n\n            const funcPosition = (watchPosition\n                ? geolocationProvider.watchPosition\n                : geolocationProvider.getCurrentPosition\n            ).bind(geolocationProvider);\n\n            if (userDecisionTimeout) {\n                this.userDecisionTimeoutId = setTimeout(() => {\n                    this.onPositionError();\n                }, userDecisionTimeout);\n            }\n\n            this.watchId = funcPosition(\n                this.onPositionSuccess,\n                this.onPositionError,\n                positionOptions,\n            );\n        };\n\n        componentDidMount() {\n            this.isCurrentlyMounted = true;\n            if (!suppressLocationOnMount) {\n                this.getLocation();\n            }\n        }\n\n        componentWillUnmount() {\n            this.isCurrentlyMounted = false;\n            this.cancelUserDecisionTimeout();\n            if (watchPosition) {\n                geolocationProvider.clearWatch(this.watchId);\n            }\n        }\n\n        render() {\n            return <WrappedComponent {...this.state} {...this.props} />;\n        }\n    };\n    result.displayName = getDisplayName(WrappedComponent);\n    result.propTypes = {\n        onError: PropTypes.func,\n        onSuccess: PropTypes.func,\n    };\n    return result;\n};\n\nexport const geoPropTypes = {\n    coords: PropTypes.shape({\n        latitude: PropTypes.number,\n        longitude: PropTypes.number,\n        altitude: PropTypes.number,\n        accuracy: PropTypes.number,\n        altitudeAccuracy: PropTypes.number,\n        heading: PropTypes.number,\n        speed: PropTypes.number,\n    }),\n    isGeolocationAvailable: PropTypes.bool,\n    isGeolocationEnabled: PropTypes.bool,\n    positionError: PropTypes.shape({\n        code: PropTypes.oneOf([1, 2, 3]),\n        message: PropTypes.string,\n    }),\n    watchPosition: PropTypes.bool,\n};\n","import React from \"react\";\nimport { geolocated, geoPropTypes } from \"../src/index\";\n\nconst getDirection = (degrees, isLongitude) =>\n    degrees > 0 ? (isLongitude ? \"E\" : \"N\") : isLongitude ? \"W\" : \"S\";\n\n// adapted from http://stackoverflow.com/a/5786281/2546338\nconst formatDegrees = (degrees, isLongitude) =>\n    `${0 | degrees}Â° ${0 |\n        (((degrees < 0 ? (degrees = -degrees) : degrees) % 1) * 60)}' ${0 |\n        (((degrees * 60) % 1) * 60)}\" ${getDirection(degrees, isLongitude)}`;\n\nconst Demo = props => (\n    <div\n        style={{\n            fontSize: \"large\",\n            fontWeight: \"bold\",\n            margin: \"2rem\",\n        }}\n    >\n        {!props.isGeolocationAvailable ? (\n            <div>Your browser does not support Geolocation.</div>\n        ) : !props.isGeolocationEnabled ? (\n            <div>Geolocation is not enabled.</div>\n        ) : props.coords ? (\n            <div>\n                You are at{\" \"}\n                <span className=\"coordinate\">\n                    {formatDegrees(props.coords.latitude, false)}\n                </span>\n                ,{\" \"}\n                <span className=\"coordinate\">\n                    {formatDegrees(props.coords.longitude, true)}\n                </span>\n                {props.coords.altitude ? (\n                    <span>\n                        , approximately {props.coords.altitude} meters above sea\n                        level\n                    </span>\n                ) : null}\n                .\n            </div>\n        ) : (\n            <div>Getting the location data&hellip;</div>\n        )}\n        {!!props.positionError && (\n            <div>\n                <br />\n                Last position error:\n                <pre>{JSON.stringify(props.positionError)}</pre>\n            </div>\n        )}\n    </div>\n);\n\nDemo.propTypes = { ...Demo.propTypes, ...geoPropTypes };\n\nexport default geolocated({\n    positionOptions: {\n        enableHighAccuracy: false,\n    },\n    userDecisionTimeout: 5000,\n})(Demo);\n","import React, { useRef } from \"react\";\nimport Demo from \"./Demo.jsx\";\n\nconst App = () => {\n    const innerRef = useRef();\n\n    const getLocation = () => {\n        innerRef.current && innerRef.current.getLocation();\n    };\n\n    return (\n        <article style={{ textAlign: \"center\" }}>\n            {/* eslint-disable-next-line no-console*/}\n            <Demo onError={error => console.log(error)} ref={innerRef} />\n            <button\n                className=\"pure-button pure-button-primary\"\n                onClick={getLocation}\n                type=\"button\"\n            >\n                Get location\n            </button>\n        </article>\n    );\n};\n\nexport default App;\n","import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/danhomola/repositories/personal/react-geolocated/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nimport App from \"./App\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <App mdxType=\"App\" />\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}